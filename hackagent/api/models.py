# Copyright 2026 - AI4I. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# This file is AUTO-GENERATED.
# Do NOT edit manually – run hackagent/api/scripts/generate.py to regenerate.

# generated by datamodel-codegen:
#   filename:  hackagent-schema-1u2NVS.json
#   timestamp: 2026-02-24T21:14:43+00:00

from __future__ import annotations

from decimal import Decimal
from enum import Enum
from typing import Annotated, Any
from urllib.parse import urlparse
from uuid import UUID

from pydantic import (
    AnyUrl,
    AwareDatetime,
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    RootModel,
)


class HackAgentBaseModel(BaseModel):
    """Base model for all hackagent API models.

    Provides backward-compatible ``additional_properties`` access for any
    extra fields returned by the server that are not declared in the schema.
    """

    model_config = ConfigDict(extra="allow")

    @property
    def additional_properties(self) -> dict:
        """Return extra fields received from the server (not in schema).

        Creates the underlying ``__pydantic_extra__`` dict on first access so
        that mutation via ``obj.additional_properties["key"] = value`` works
        even when the model is frozen.
        """
        if self.__pydantic_extra__ is None:
            # Bypass frozen __setattr__ to initialise the extras dict.
            object.__setattr__(self, "__pydantic_extra__", {})
        return self.__pydantic_extra__  # type: ignore[return-value]

    @additional_properties.setter
    def additional_properties(self, value: dict) -> None:
        if self.__pydantic_extra__ is None:
            object.__setattr__(self, "__pydantic_extra__", {})
        self.__pydantic_extra__.update(value)  # type: ignore[union-attr]

    def __getitem__(self, item: str) -> Any:
        """Access extra (non-schema) fields with dict syntax: ``model["key"]``."""
        return self.additional_properties[item]

    @staticmethod
    def _normalize_url_strings(data: Any) -> None:
        """Strip trailing slashes from bare-domain URLs added by Pydantic's AnyUrl.

        Pydantic v2 normalises ``http://host:port`` → ``http://host:port/``.
        Many backends reject (or crash on) the added slash, so we strip it when
        the URL path is nothing but that root slash.
        """
        if not isinstance(data, dict):
            return
        for key, val in data.items():
            if isinstance(val, str) and val.endswith("/") and "://" in val:
                parsed = urlparse(val)
                if parsed.path == "/":  # only bare-domain root slash
                    data[key] = val.rstrip("/")
            elif isinstance(val, dict):
                HackAgentBaseModel._normalize_url_strings(val)

    def model_dump(self, **kwargs: Any) -> dict[str, Any]:  # type: ignore[override]
        """Return a dict representation, stripping Pydantic-added trailing URL slashes."""
        result = super().model_dump(**kwargs)
        if kwargs.get("mode") == "json":
            HackAgentBaseModel._normalize_url_strings(result)
        return result


class APITokenLog(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: int
    timestamp: AwareDatetime
    api_key_prefix: Annotated[str | None, Field(...)]
    user_username: Annotated[str | None, Field(...)]
    organization_name: Annotated[str | None, Field(...)]
    model_id_used: str
    """
    Identifier of the AI model used.
    """
    api_endpoint: str
    """
    Internal endpoint name, e.g., 'generator' or 'judge'.
    """
    input_tokens: int
    output_tokens: int
    credits_deducted: Decimal
    request_payload_preview: Annotated[str | None, Field(title="Request Preview")]
    """
    First ~256 chars of request payload
    """
    response_payload_preview: Annotated[str | None, Field(title="Response Preview")]
    """
    First ~256 chars of response payload
    """


class AgentRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Annotated[str, Field(max_length=200, min_length=1, title="Agent Name")]
    endpoint: Annotated[AnyUrl, Field(title="Endpoint URL")]
    """
    The primary API endpoint URL for interacting with the agent.
    """
    agent_type: Annotated[
        str | None, Field(max_length=50, title="Agent SDK/ADK Type")
    ] = None
    """
    The specific SDK, ADK, or API type the agent is built upon (e.g., OpenAI SDK, Generic ADK).
    """
    description: str | None = None
    metadata: Any | None = None
    """
    Optional JSON data providing specific details and configuration. Structure depends heavily on Agent Type. Examples:
    - For GENERIC_ADK: {'adk_app_name': 'my_adk_app', 'protocol_version': '1.0'}
    - For OPENAI_SDK: {'model': 'gpt-4-turbo', 'api_key_secret_name': 'MY_OPENAI_KEY', 'instructions': 'You are a helpful assistant.'}
    - For GOOGLE_ADK: {'project_id': 'my-gcp-project', 'location': 'us-central1'}
    - General applicable: {'version': '1.2.0', 'custom_headers': {'X-Custom-Header': 'value'}}
    """


class Attack(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    type: Annotated[str, Field(max_length=100, title="Attack Type")]
    """
    A string identifier for the type of attack being configured (e.g., 'PREFIX_GENERATION', 'PROMPT_INJECTION').
    """
    agent: Annotated[UUID, Field(title="Target Agent")]
    agent_name: str
    owner: Annotated[int | None, Field(title="Defined By")]
    owner_username: str
    organization: UUID
    organization_name: str
    configuration: Annotated[Any, Field(title="Attack Configuration")]
    """
    JSON containing client-provided configuration for an attack using this definition.
    """
    created_at: AwareDatetime
    updated_at: AwareDatetime


class AttackRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    type: Annotated[str, Field(max_length=100, min_length=1, title="Attack Type")]
    """
    A string identifier for the type of attack being configured (e.g., 'PREFIX_GENERATION', 'PROMPT_INJECTION').
    """
    agent: Annotated[UUID, Field(title="Target Agent")]
    configuration: Annotated[Any, Field(title="Attack Configuration")]
    """
    JSON containing client-provided configuration for an attack using this definition.
    """


class CheckoutSessionRequestRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    credits_to_purchase: Annotated[int, Field(ge=1)]
    """
    Number of credits the user wants to purchase.
    """


class CheckoutSessionResponse(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    checkout_url: AnyUrl
    """
    The URL to redirect the user to for Stripe Checkout.
    """


class ChoiceMessage(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    role: str
    """
    Role of the message sender
    """
    content: str
    """
    Generated content
    """


class EvaluationStatusEnum(Enum):
    NOT_EVALUATED = "NOT_EVALUATED"
    SUCCESSFUL_JAILBREAK = "SUCCESSFUL_JAILBREAK"
    FAILED_JAILBREAK = "FAILED_JAILBREAK"
    ERROR_AGENT_RESPONSE = "ERROR_AGENT_RESPONSE"
    ERROR_TEST_FRAMEWORK = "ERROR_TEST_FRAMEWORK"
    PASSED_CRITERIA = "PASSED_CRITERIA"
    FAILED_CRITERIA = "FAILED_CRITERIA"


class GenerateErrorResponse(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    error: str
    """
    Description of the error that occurred.
    """


class StopItem(RootModel[str]):
    model_config = ConfigDict(
        frozen=True,
    )
    root: Annotated[str, Field(min_length=1)]


class GenericErrorResponse(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    error: str
    details: str | None = None


class MessageRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    role: Annotated[str, Field(min_length=1)]
    """
    Role of the message sender (system, user, assistant)
    """
    content: Annotated[str, Field(min_length=1)]
    """
    Content of the message
    """


class Organization(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    name: Annotated[str, Field(max_length=200, title="Organization Name")]
    created_at: AwareDatetime
    updated_at: AwareDatetime
    credits: Decimal
    """
    Available API credit balance in USD for the organization.
    """
    credits_last_updated: AwareDatetime
    """
    Timestamp of the last credit balance update.
    """


class OrganizationMinimal(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    name: Annotated[str, Field(title="Organization Name")]


class OrganizationRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Annotated[str, Field(max_length=200, min_length=1, title="Organization Name")]


class PaginatedAPITokenLogList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[APITokenLog]


class PaginatedAttackList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[Attack]


class PaginatedOrganizationList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[Organization]


class PatchedAgentRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Annotated[
        str | None, Field(max_length=200, min_length=1, title="Agent Name")
    ] = None
    endpoint: Annotated[AnyUrl | None, Field(title="Endpoint URL")] = None
    """
    The primary API endpoint URL for interacting with the agent.
    """
    agent_type: Annotated[
        str | None, Field(max_length=50, title="Agent SDK/ADK Type")
    ] = None
    """
    The specific SDK, ADK, or API type the agent is built upon (e.g., OpenAI SDK, Generic ADK).
    """
    description: str | None = None
    metadata: Any | None = None
    """
    Optional JSON data providing specific details and configuration. Structure depends heavily on Agent Type. Examples:
    - For GENERIC_ADK: {'adk_app_name': 'my_adk_app', 'protocol_version': '1.0'}
    - For OPENAI_SDK: {'model': 'gpt-4-turbo', 'api_key_secret_name': 'MY_OPENAI_KEY', 'instructions': 'You are a helpful assistant.'}
    - For GOOGLE_ADK: {'project_id': 'my-gcp-project', 'location': 'us-central1'}
    - General applicable: {'version': '1.2.0', 'custom_headers': {'X-Custom-Header': 'value'}}
    """


class PatchedAttackRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    type: Annotated[
        str | None, Field(max_length=100, min_length=1, title="Attack Type")
    ] = None
    """
    A string identifier for the type of attack being configured (e.g., 'PREFIX_GENERATION', 'PROMPT_INJECTION').
    """
    agent: Annotated[UUID | None, Field(title="Target Agent")] = None
    configuration: Annotated[Any | None, Field(title="Attack Configuration")] = None
    """
    JSON containing client-provided configuration for an attack using this definition.
    """


class PatchedOrganizationRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Annotated[
        str | None, Field(max_length=200, min_length=1, title="Organization Name")
    ] = None


class PatchedPromptRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Annotated[
        str | None, Field(max_length=200, min_length=1, title="Prompt Name")
    ] = None
    prompt_text: Annotated[str | None, Field(min_length=1)] = None
    category: Annotated[str | None, Field(max_length=100)] = None
    """
    Primary category for grouping prompts (e.g., Evasion, Harmful Content).
    """
    tags: Any | None = None
    """
    Optional JSON list of tags for classification (e.g., ["PII", "Malware"])
    """
    evaluation_criteria: str | None = None
    """
    Description of how success/failure should be judged for this specific prompt.
    """
    expected_tool_calls: Any | None = None
    """
    JSON list of expected tool calls, e.g., [{"tool_name": "...", "tool_input": {...}}]
    """
    expected_output_pattern: Annotated[
        str | None, Field(title="Expected Output Pattern (Regex)")
    ] = None
    """
    Optional regex pattern to match against the final response.
    """
    reference_output: str | None = None
    """
    Optional ideal/reference final output text.
    """


class PatchedResultRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    run: UUID | None = None
    prompt: UUID | None = None
    request_payload: Any | None = None
    """
    Payload sent to agent or relevant data for client-submitted results.
    """
    response_status_code: Annotated[
        int | None, Field(ge=-2147483648, le=2147483647)
    ] = None
    response_headers: Any | None = None
    response_body: str | None = None
    latency_ms: Annotated[
        int | None, Field(ge=0, le=2147483647, title="Latency (ms)")
    ] = None
    detected_tool_calls: Any | None = None
    evaluation_status: EvaluationStatusEnum | None = None
    evaluation_notes: str | None = None
    evaluation_metrics: Any | None = None
    agent_specific_data: Any | None = None


class PatchedUserProfileRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    email: Annotated[EmailStr | None, Field(min_length=1)] = None
    first_name: str | None = None
    last_name: str | None = None


class PromptRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Annotated[str, Field(max_length=200, min_length=1, title="Prompt Name")]
    prompt_text: Annotated[str, Field(min_length=1)]
    category: Annotated[str | None, Field(max_length=100)] = None
    """
    Primary category for grouping prompts (e.g., Evasion, Harmful Content).
    """
    tags: Any | None = None
    """
    Optional JSON list of tags for classification (e.g., ["PII", "Malware"])
    """
    evaluation_criteria: str | None = None
    """
    Description of how success/failure should be judged for this specific prompt.
    """
    expected_tool_calls: Any | None = None
    """
    JSON list of expected tool calls, e.g., [{"tool_name": "...", "tool_input": {...}}]
    """
    expected_output_pattern: Annotated[
        str | None, Field(title="Expected Output Pattern (Regex)")
    ] = None
    """
    Optional regex pattern to match against the final response.
    """
    reference_output: str | None = None
    """
    Optional ideal/reference final output text.
    """


class ResultRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    run: UUID
    prompt: UUID | None = None
    request_payload: Any | None = None
    """
    Payload sent to agent or relevant data for client-submitted results.
    """
    response_status_code: Annotated[
        int | None, Field(ge=-2147483648, le=2147483647)
    ] = None
    response_headers: Any | None = None
    response_body: str | None = None
    latency_ms: Annotated[
        int | None, Field(ge=0, le=2147483647, title="Latency (ms)")
    ] = None
    detected_tool_calls: Any | None = None
    evaluation_status: EvaluationStatusEnum | None = None
    evaluation_notes: str | None = None
    evaluation_metrics: Any | None = None
    agent_specific_data: Any | None = None


class StatusEnum(Enum):
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    COMPLETED = "COMPLETED"
    FAILED = "FAILED"
    CANCELLED = "CANCELLED"


class StepTypeEnum(Enum):
    TOOL_CALL = "TOOL_CALL"
    TOOL_RESPONSE = "TOOL_RESPONSE"
    AGENT_THOUGHT = "AGENT_THOUGHT"
    AGENT_RESPONSE_CHUNK = "AGENT_RESPONSE_CHUNK"
    OTHER = "OTHER"
    MCP_STEP = "MCP_STEP"
    A2_A_COMM = "A2A_COMM"


class Trace(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: int
    result: UUID
    sequence: Annotated[int, Field(ge=0, le=2147483647)]
    step_type: StepTypeEnum | None = None
    timestamp: AwareDatetime
    content: Any | None = None


class TraceRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    sequence: Annotated[int, Field(ge=0, le=2147483647)]
    step_type: StepTypeEnum | None = None
    content: Any | None = None


class Usage(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    prompt_tokens: int
    """
    Number of tokens in the prompt
    """
    completion_tokens: int
    """
    Number of tokens in the completion
    """
    total_tokens: int
    """
    Total tokens used
    """


class UserAPIKeyRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    name: Annotated[str, Field(max_length=50, min_length=1)]
    """
    A human-readable name for the API key.
    """
    key: Annotated[str | None, Field(min_length=1)] = None


class UserProfile(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    user: int
    username: str
    email: EmailStr | None = None
    first_name: str | None = None
    last_name: str | None = None
    organization: UUID
    organization_name: str
    auth0_user_id: Annotated[str | None, Field(...)]
    """
    The unique user identifier (sub claim) provided by Auth0.
    """


class UserProfileMinimal(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    user: int
    username: str
    organization: UUID


class UserProfileRequest(PatchedUserProfileRequest):
    pass


class Agent(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    name: Annotated[str, Field(max_length=200, title="Agent Name")]
    endpoint: Annotated[AnyUrl, Field(title="Endpoint URL")]
    """
    The primary API endpoint URL for interacting with the agent.
    """
    agent_type: Annotated[
        str | None, Field(max_length=50, title="Agent SDK/ADK Type")
    ] = None
    """
    The specific SDK, ADK, or API type the agent is built upon (e.g., OpenAI SDK, Generic ADK).
    """
    description: str | None = None
    metadata: Any | None = None
    """
    Optional JSON data providing specific details and configuration. Structure depends heavily on Agent Type. Examples:
    - For GENERIC_ADK: {'adk_app_name': 'my_adk_app', 'protocol_version': '1.0'}
    - For OPENAI_SDK: {'model': 'gpt-4-turbo', 'api_key_secret_name': 'MY_OPENAI_KEY', 'instructions': 'You are a helpful assistant.'}
    - For GOOGLE_ADK: {'project_id': 'my-gcp-project', 'location': 'us-central1'}
    - General applicable: {'version': '1.2.0', 'custom_headers': {'X-Custom-Header': 'value'}}
    """
    organization: UUID
    organization_detail: OrganizationMinimal
    owner: Annotated[int | None, Field(...)]
    owner_detail: Annotated[UserProfileMinimal | None, Field(...)]
    created_at: AwareDatetime
    updated_at: AwareDatetime


class Choice(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    index: int
    """
    Index of the choice
    """
    message: ChoiceMessage
    """
    Message object
    """
    finish_reason: str
    """
    Reason for completion (stop, length, etc.)
    """


class GenerateRequestRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    model: Annotated[str | None, Field(min_length=1)] = None
    """
    Client-specified model (will be overridden by server)
    """
    messages: list[MessageRequest]
    """
    Array of conversation messages
    """
    stream: bool = False
    """
    Whether to stream the response
    """
    temperature: float | None = None
    """
    Sampling temperature (0-2)
    """
    max_tokens: int | None = None
    """
    Maximum tokens to generate
    """
    top_p: float | None = None
    """
    Nucleus sampling threshold
    """
    frequency_penalty: float | None = None
    """
    Frequency penalty (-2.0 to 2.0)
    """
    presence_penalty: float | None = None
    """
    Presence penalty (-2.0 to 2.0)
    """
    stop: list[StopItem] | None = None
    """
    Sequences where the API will stop generating
    """


class GenerateSuccessResponse(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: str
    """
    Unique identifier for the completion
    """
    object: str
    """
    Object type (chat.completion)
    """
    created: int
    """
    Unix timestamp of creation
    """
    model: str
    """
    Model used for generation
    """
    choices: list[Choice]
    """
    Array of completion choices
    """
    usage: Usage
    """
    Token usage information
    """


class PaginatedAgentList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[Agent]


class PaginatedUserProfileList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[UserProfile]


class PatchedRunRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    agent: UUID | None = None
    attack: Annotated[UUID | None, Field(title="Associated Attack")] = None
    """
    The Attack this run is an instance of, if applicable.
    """
    run_config: Annotated[Any | None, Field(title="Run Configuration")] = None
    """
    JSON containing specific settings for this run. If linked to an Attack, this might be a copy or subset of its configuration.
    """
    status: StatusEnum | None = None
    run_notes: str | None = None


class Prompt(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    name: Annotated[str, Field(max_length=200, title="Prompt Name")]
    prompt_text: str
    category: Annotated[str | None, Field(max_length=100)] = None
    """
    Primary category for grouping prompts (e.g., Evasion, Harmful Content).
    """
    tags: Any | None = None
    """
    Optional JSON list of tags for classification (e.g., ["PII", "Malware"])
    """
    evaluation_criteria: str | None = None
    """
    Description of how success/failure should be judged for this specific prompt.
    """
    expected_tool_calls: Any | None = None
    """
    JSON list of expected tool calls, e.g., [{"tool_name": "...", "tool_input": {...}}]
    """
    expected_output_pattern: Annotated[
        str | None, Field(title="Expected Output Pattern (Regex)")
    ] = None
    """
    Optional regex pattern to match against the final response.
    """
    reference_output: str | None = None
    """
    Optional ideal/reference final output text.
    """
    organization: UUID
    organization_detail: OrganizationMinimal
    owner: Annotated[int | None, Field(...)]
    owner_detail: Annotated[UserProfileMinimal | None, Field(...)]
    created_at: AwareDatetime
    updated_at: AwareDatetime


class Result(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    run: UUID
    run_id: UUID
    prompt: UUID | None = None
    prompt_name: Annotated[str | None, Field(...)]
    request_payload: Any | None = None
    """
    Payload sent to agent or relevant data for client-submitted results.
    """
    response_status_code: Annotated[
        int | None, Field(ge=-2147483648, le=2147483647)
    ] = None
    response_headers: Any | None = None
    response_body: str | None = None
    latency_ms: Annotated[
        int | None, Field(ge=0, le=2147483647, title="Latency (ms)")
    ] = None
    detected_tool_calls: Any | None = None
    evaluation_status: EvaluationStatusEnum | None = None
    evaluation_notes: str | None = None
    evaluation_metrics: Any | None = None
    agent_specific_data: Any | None = None
    timestamp: AwareDatetime
    traces: list[Trace]


class Run(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: UUID
    agent: UUID
    agent_name: str
    attack: Annotated[UUID | None, Field(title="Associated Attack")] = None
    """
    The Attack this run is an instance of, if applicable.
    """
    owner: Annotated[int | None, Field(title="Initiated By")]
    owner_username: Annotated[str | None, Field(...)]
    organization: UUID
    organization_name: str
    run_config: Annotated[Any | None, Field(title="Run Configuration")] = None
    """
    JSON containing specific settings for this run. If linked to an Attack, this might be a copy or subset of its configuration.
    """
    timestamp: AwareDatetime
    status: StatusEnum | None = None
    run_notes: str | None = None
    is_client_executed: bool
    """
    Indicates if the run was initiated via an Attack by a client application.
    """
    results: list[Result]


class RunRequest(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    agent: UUID
    attack: Annotated[UUID | None, Field(title="Associated Attack")] = None
    """
    The Attack this run is an instance of, if applicable.
    """
    run_config: Annotated[Any | None, Field(title="Run Configuration")] = None
    """
    JSON containing specific settings for this run. If linked to an Attack, this might be a copy or subset of its configuration.
    """
    status: StatusEnum | None = None
    run_notes: str | None = None


class UserAPIKey(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    id: str
    name: Annotated[str, Field(max_length=50)]
    """
    A human-readable name for the API key.
    """
    prefix: str
    created: AwareDatetime
    revoked: bool
    """
    If the API key is revoked, clients cannot use it anymore. (This cannot be undone.)
    """
    expiry_date: Annotated[AwareDatetime | None, Field(title="Expires")]
    """
    Once API key expires, clients cannot use it anymore.
    """
    user: int
    user_detail: Annotated[UserProfileMinimal | None, Field(...)]
    organization: UUID
    organization_detail: Annotated[OrganizationMinimal | None, Field(...)]


class PaginatedPromptList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[Prompt]


class PaginatedResultList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[Result]


class PaginatedRunList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[Run]


class PaginatedUserAPIKeyList(HackAgentBaseModel):
    model_config = ConfigDict(
        frozen=True,
    )
    count: Annotated[int, Field(examples=[123])]
    next: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=4"])
    ] = None
    previous: Annotated[
        AnyUrl | None, Field(examples=["http://api.example.org/accounts/?page=2"])
    ] = None
    results: list[UserAPIKey]
